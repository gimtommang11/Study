# 동적 계획법(Dynamic Programming)

큰 문제를 작은 문제로 나눠서 푸는 알고리즘

이름이 "동적"계획법인 이유는 그저 멋있어서 지은것이라고 한다.



### 방법

동적계획법은 나눈 작은 문제들이 **반복**되고, 그 반복되는 문제들은 구할때마다 **정답이 같다** 라는 것을 전재로 한다.

이렇게 나눈 작은 문제들의 값을 **메모** 한 후, 큰 문제를 풀 때 똑같은 작은 문제가 나타나면 **메모해둔 값**을 이용해 푸는 것 이다.

#### 메모이제이션

여기서 작은 문제들의 값을 메모해서, 큰 문제를 풀 때 사용한다고 했는데 이것을 **메모이제이션** 이라고 한다.

메모이제이션은 저장된 결과를 배열에 저장해서, 다음 계산이 필요할 때 저장된 값을 불러오는것으로 구현할 수 있다.

메모이제이션의 장점은 중복된 함수 호출을 줄여주므로 시간 복잡도가 줄어든다.

대표적인 예시로는 **피보나치 수열**이 있다.



#### 분할정복과의 차이

분할정복은 큰 문제를 해결하기 어려울때, 문제를 나눌 수 없을때까지 나누어서 각 문제를 푼 후 합쳐서 문제의 답을 얻는 알고리즘이다

동적계획법은 이런 면에서 분할정복과 닮아있지만, **분할 정복**은 그냥 **나눠서 푸는 것**이고 **동적 계획법**은 작은 부분들이 **반복되는것**을 이용해 문제를 푸는것으로 다르다.



#### 탐욕법(그리디 알고리즘)과의 차이

탐욕법은 문제를 해결하는 과정에서 그 순간순간마다 최적이라고 생각되는 경로를 통해 결과값을 구하는 방식이다.

그에 반해서 동적 계획법은 최종 결과를 구하기 위해 모든 경로를 가보는 방식이다. 

둘은 서로 장단점이 존재하는데, 

**탐욕법**은 각 순간마다 최적의 해를 찾아가므로 빠르지만, 결과값이 틀릴수도 있다.

**동적계획법**은 각 경로를 모두 가봐야 하기 때문에 느리지만,  정답률이  높다.

이 두 알고리즘은 서로 상반되는 장단점이 있으므로 각 문제마다 적절이 파학하여 사용하는것이 좋다.