# :computer: 가상메모리

## 가상메모리란?

메인 메모리보다 훨씬 큰 기억공간인 디스크를 가상의 메모리 공간으로 이용하는 기법

만약, 당신이 요리를 할 때, 모든 재료들을 도마에 모두 올려두고 한다면 도마의 크기가 부족 할 수가 있다. 그런데 만약, 냉장고를 두어서 재료를 모아두고 그때그때 필요한 재료만 가져와서 작업한다면 이런 문제를 해결할 수 있다.

여기서 도마가 실제 메모리, 냉장고를 가상 메모리라고 볼 수 있다.

#### 용어정리

- 페이지: 가상 메모리를 같은 크기의 블록으로 나눈 것
- 프레임: ram을 페이지와 같은 크기로 나눈 것. 
- 램이 n바이트 필요한다는것은 어플리케이션의 주소 공간이라고 부름
  - 주소 공간: 에플레케이션/테이터를 모두 저장하는데 필요한 고유 주소의 수

#### 가상메모리의 등장

~~두둥등장~~

 가상메모리 등장 전에는, 주기억장치(RAM)에 실행할 프로그램 전체를 적제했다. 하지만 이런 방법에는 단점이 존재했는데

- 주기억장치 크기보다 더 큰 프로그램을 실행 할 수 없다
- 프로그램이 실행될 때 다른작업은 할 수 없다.

그래서 나온 것이 **가상 메모리**로 **필요한 부분만 메모리에 올리는 것** 이다. 

#### 가상 메모리와 MMU



## 요구 페이징

지금의 가상 메모리 기법을 존재하게 한 것

대부분의 프로그램이 프로그램 전체가 적제되지 않아도 **사용 가능하다**는 특징을 이용해서, **필요한 페이지**만 저장공간에 적제하고, 다른 페이지는 **보조기억장치**에 적제해서 사용한다.

![ ](..\images\virtual_memory\demend_paging.png)

#### 용어정리

- 논리적 메모리 : 프로그램들이 보는 메모리, 순서대로 주소가 부여됨
- 물리적 메모리 : 실제로 존재하는 메모리,  
- 페이지 테이블 : 페이징 기법에서 사용된는 자료구조
- 페이징 기법: 

여기서 페이지 테이블은 **타당,비타당 비트** 가 추가되었는데, 이는 필요한 페이지가 물리적 메모리에 있는지 없는지를 확인하기 위함이다.

- 타당(Vaild):  물리적 메모리에 존재한다 
- 비타당(invaild):  물리적 메모리에 존재하지 않는다.

타당 비트가 나오면 실행하면 되지만, 비타당 비트가 나온다면 어떻게 해야 할까? :thinking:

### 페이지 부재 처리

저장되어있지 않은 페이지를 사용하기 위해서는 보조기억장치에서 필요한 페이지를 가져오면 된다.

![page_fault_process](..\images\virtual_memory\page_fault_process.png)

이렇게 문제가 생기면 MMU에서 운영체제로 제어권을 넘긴다. 그러면 운영체제는 비어있는 프레임 리스트 중 하나를 선택하여, 프레임에 요구된 페이지를 보조기억장치에서 읽어들인다. 그 후 페이지 테이블을 수정하고 처음부터 다시 시작한다.

만약, 프레임 리스트가 페이지로 꽉 찼다면 어떻게 할까?

## 페이지 교체 알고리즘

그렇다면 물리메모리에 있는 페이지와 보조기억장치에 있는 페이지를 바꿔야 할 것이다. 

크게 세 종류의 페이지 교체 알고리즘이 있다.

- ### FIFO(First-In-First-Out) 알고리즘

  **가장 먼저 들어온 페이지**를 교체한다

  ![FIFO알고리즘](..\images\virtual_memory\FIFO알고리즘.png)

  세 개의 알고리즘 중, 가장 간단한 방법이다. 

  벨레디의 변의 현상이 발생할 수도 있어서 성능이 항상 좋은 것은 아니다

  #### 벨레디의 변의

  프레임이 늘어날수록, 페이지 부재가 줄어들어야 하지만 , 더 늘어나는 현상

  중요한 페이지가 계속 사용될 가능성이 있더라도, 그저 오랬동안 있었다고 교체하기 때문이다

- ### Optimal 알고리즘

  앞으로 가장 사용하지 않을 것 같은 페이지를 교체한다.

  ![최적알고리즘](..\images\virtual_memory\최적알고리즘.png)

  이름과 같이 최적으로 페이지 결함이 나올 횟수가 적다. 

  페이지가 얼마나 오랜기가 사용되지 않을지 예측하기 힘들어서 **실제 구현이 힘들다**

- ### LRU(Least-Recently-Used) 알고리즘

  가장 오랬동안 사용되지 않은 페이지를 교체한다.

  ![LRU알고리즘](..\images\virtual_memory\LRU알고리즘.png)

실제로 사용할 수 있는 알고리즘 중에서 가장 좋은 방법이다.

